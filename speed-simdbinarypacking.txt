// I ran a few versions of rewriting the loops of simdbinarypacking.h
//
// Compare speeds (16x repeated at sudo nice -n-8)
//
// ORIGINAL ------->    1250+/-19  1245+/-9   1140+/-5    mis for compression tests 1,2,3
// NEW   ---------->    1370+/-30  1334+/-26  1311+/-39   mis compression for tests 1,2,3
//                      +9.6%      +7%        15%  speedup
// Someday, consider making format endian-safe
//      Write/ReadLittleEndian(uint32_t,uint32_t) ?
//
    void encodeArray(const uint32_t *in, const size_t length, uint32_t *out,
            size_t &nvalue) {
        checkifdivisibleby(length, BlockSize);
        const uint32_t * const initout(out);
        *out++ = static_cast<uint32_t>(length);
        while(needPaddingTo128Bits(out)) *out++ = CookiePadder;
        //uint32_t Bs[HowManyMiniBlocks];
        // Compare speeds (16x repeated at sudo nice -n-8)
        //
        // ORIGINAL ------->    1250+/-19  1245+/-9   1140+/-5    mis for compression tests 1,2,3
        // NEW   ---------->    1370+/-30  1334+/-26  1311+/-39   mis compression for tests 1,2,3
        //
#if 0 // ORIGINAL
        //   1235 1253 1311 mis (testAll-trunk.log)
        // #test 1 of 3      #test 2 of 3      #test 3 of 3
        // 1249    1583      1257    1498      1139    1455
        // 1259    1588      1220    1491      1137    1458
        // 1262    1560      1247    1505      1138    1456
        // 1255    1577      1249    1495      1135    1459
        // 1248    1597      1254    1516      1140    1451
        // 1253    1592      1253    1497      1141    1452
        // 1251    1596      1246    1497      1140    1454
        // 1249    1575      1249    1497      1141    1472
        // 1249    1580      1247    1471      1157    1455
        // 1253    1588      1234    1488      1139    1460
        // 1263    1573      1252    1493      1138    1459
        // 1260    1603      1251    1496      1141    1458
        // 1218    1616      1237    1490      1137    1449
        // 1255    1632      1238    1490      1143    1445
        // 1284    1587      1253    1493      1145    1444
        // 1194    1533      1246    1496      1142    1446
        /*
import numpy as np
b = np.array([[ 1249,1583,1257,1498,1139,1455 ],
              [ 1259,1588,1220,1491,1137,1458 ],
              [ 1262,1560,1247,1505,1138,1456 ],
              [ 1255,1577,1249,1495,1135,1459 ],
              [ 1248,1597,1254,1516,1140,1451 ],
              [ 1253,1592,1253,1497,1141,1452 ],
              [ 1251,1596,1246,1497,1140,1454 ],
              [ 1249,1575,1249,1497,1141,1472 ],
              [ 1249,1580,1247,1471,1157,1455 ],
              [ 1253,1588,1234,1488,1139,1460 ],
              [ 1263,1573,1252,1493,1138,1459 ],
              [ 1260,1603,1251,1496,1141,1458 ],
              [ 1218,1616,1237,1490,1137,1449 ],
              [ 1255,1632,1238,1490,1143,1445 ],
              [ 1284,1587,1253,1493,1145,1444 ],
              [ 1194,1533,1246,1496,1142,1446 ]])
print np.mean(b[:,0]), np.mean(b[:,1]), np.mean(b[:,2]), np.mean(b[:,3]), np.mean(b[:,4]), np.mean(b[:,5])
print np.std(b[:,0]), np.std(b[:,1]), np.std(b[:,2]), np.std(b[:,3]), np.std(b[:,4]), np.std(b[:,5])
         */
        // >>> print np.mean(b[:,0]), np.mean(b[:,1]), np.mean(b[:,2]), np.mean(b[:,3]), np.mean(b[:,4]), np.mean(b[:,5])
        // 1250.125 1586.25 1245.8125 1494.5625 1140.8125 1454.5625
        // >>> print np.std(b[:,0]), np.std(b[:,1]), np.std(b[:,2]), np.std(b[:,3]), np.std(b[:,4]), np.std(b[:,5])
        // 19.1796604506 21.608736659 9.11193413881 8.87389957967 4.82465996211 6.73580683734
        // >>> 
        // ------->    1250+/19  1245+/-9    1140+/-5   mis for compression tests 1,2,3
        //
        for (const uint32_t * const final = in + length; in + BlockSize
                <= final; in += BlockSize) {
            for (uint32_t i = 0; i < HowManyMiniBlocks; ++i)
                Bs[i] = maxbits(in + i * MiniBlockSize,
                        in + (i + 1) * MiniBlockSize);
            *out++ = (Bs[0] << 24) | (Bs[1] << 16) | (Bs[2] << 8)
                | Bs[3];
            *out++ = (Bs[4] << 24) | (Bs[5] << 16) | (Bs[6] << 8)
                            | Bs[7];
            *out++ = (Bs[8] << 24) | (Bs[9] << 16) | (Bs[10] << 8)
                            | Bs[11];
            *out++ = (Bs[12] << 24) | (Bs[13] << 16) | (Bs[14] << 8)
                            | Bs[15];
            for (uint32_t i = 0; i < HowManyMiniBlocks; ++i) {
                // D.L. : is the reinterpret_cast safe here?
                SIMD_fastpackwithoutmask_32(in + i * MiniBlockSize, reinterpret_cast<__m128i *>(out),
                                Bs[i]);
                out += MiniBlockSize/32 * Bs[i];
            }
        }
#endif
#if 1 // 1341
        for (const uint32_t * const final = in + length; in + BlockSize
                <= final; in += BlockSize) {
            uint32_t *out0 = out;
            out += HowManyMiniBlocks / 4U;
            for (uint32_t i = 0; i < HowManyMiniBlocks; ++i) {
                Bs[i] = maxbits(in + i * MiniBlockSize,
                        in + (i + 1) * MiniBlockSize);
                // D.L. : is the reinterpret_cast safe here?
                SIMD_fastpackwithoutmask_32(in + i * MiniBlockSize, reinterpret_cast<__m128i *>(out),
                                Bs[i]);
                out += MiniBlockSize/32 * Bs[i];
            }
#if 1 //1341
            *out0 = (Bs[0] << 24) | (Bs[1] << 16) | (Bs[2] << 8) | Bs[3];
            *++out0 = (Bs[4] << 24) | (Bs[5] << 16) | (Bs[6] << 8) | Bs[7];
            *++out0 = (Bs[8] << 24) | (Bs[9] << 16) | (Bs[10] << 8) | Bs[11];
            *++out0 = (Bs[12] << 24) | (Bs[13] << 16) | (Bs[14] << 8) | Bs[15];
#else // 1284
            for(uint32_t i=0U; i < HowManyMiniBlocks; i+=4)
                *out0++ = (Bs[i+0] << 24) | (Bs[i+1] << 16) | (Bs[i+2] << 8) | Bs[i+3];
#endif
        }
#endif
#if 1 // NEW
        //     1419 1377 1402 <-- ALL better
        // sudo nice -n-8 ./codecssnappy --codecs=simdbinarypacking,simdbinarypacking,...(16x) --uniformdynamic :
        //     #test 1 of 3      #test 2 of 3      #test 3 of 3
        //     1391    1708      1281    1451      1344    1590
        //     1400    1656      1286    1518      1312    1596
        //     1389    1664      1319    1544      1304    1608
        //     1367    1663      1376    1543      1320    1594
        //     1376    1680      1344    1499      1313    1600
        //     1383    1656      1331    1495      1319    1602
        //     1389    1644      1312    1493      1238    1528
        //     1379    1665      1354    1547      1244    1475
        //     1401    1645      1367    1492      1225    1628
        //     1378    1653      1329    1497      1342    1627
        //     1374    1657      1315    1509      1345    1631
        //     1385    1635      1328    1479      1348    1633
        //     1386    1617      1359    1486      1348    1616
        //     1303    1657      1349    1487      1316    1531
        //     1307    1646      1346    1486      1320    1614
        //     1321    1590      1344    1497      1332    1627
        /*
import numpy as np
b=np.array( [[  1391 ,  1708 ,    1281 ,  1451 ,    1344 ,  1590 ],
             [  1400 ,  1656 ,    1286 ,  1518 ,    1312 ,  1596 ],
             [  1389 ,  1664 ,    1319 ,  1544 ,    1304 ,  1608 ],
             [  1367 ,  1663 ,    1376 ,  1543 ,    1320 ,  1594 ],
             [  1376 ,  1680 ,    1344 ,  1499 ,    1313 ,  1600 ],
             [  1383 ,  1656 ,    1331 ,  1495 ,    1319 ,  1602 ],
             [  1389 ,  1644 ,    1312 ,  1493 ,    1238 ,  1528 ],
             [  1379 ,  1665 ,    1354 ,  1547 ,    1244 ,  1475 ],
             [  1401 ,  1645 ,    1367 ,  1492 ,    1225 ,  1628 ],
             [  1378 ,  1653 ,    1329 ,  1497 ,    1342 ,  1627 ],
             [  1374 ,  1657 ,    1315 ,  1509 ,    1345 ,  1631 ],
             [  1385 ,  1635 ,    1328 ,  1479 ,    1348 ,  1633 ],
             [  1386 ,  1617 ,    1359 ,  1486 ,    1348 ,  1616 ],
             [  1303 ,  1657 ,    1349 ,  1487 ,    1316 ,  1531 ],
             [  1307 ,  1646 ,    1346 ,  1486 ,    1320 ,  1614 ],
             [  1321 ,  1590 ,    1344 ,  1497 ,    1332 ,  1627 ]] )
print np.mean(b[:,0]), np.mean(b[:,1]), np.mean(b[:,2]), np.mean(b[:,3]), np.mean(b[:,4]), np.mean(b[:,5])
print np.std(b[:,0]), np.std(b[:,1]), np.std(b[:,2]), np.std(b[:,3]), np.std(b[:,4]), np.std(b[:,5])
         */
        // >>> print np.mean(b[:,0]), np.mean(b[:,1]), np.mean(b[:,2]), np.mean(b[:,3]), np.mean(b[:,4]), np.mean(b[:,5])
        // 1370.5625 1652.25 1333.75 1501.4375 1310.625 1593.75
        // >>> print np.std(b[:,0]), np.std(b[:,1]), np.std(b[:,2]), np.std(b[:,3]), np.std(b[:,4]), np.std(b[:,5])
        // 30.345857934 24.9286481784 25.8589926331 24.9072498231 38.6504770346 43.2355467179
        // ----------> 1370+/-30  1334+/-26  1311+/-39   mis compression for tests 1,2,3
        //
        uint32_t const* inNxt = in + BlockSize;
        for (const uint32_t * const final = in + length; inNxt <= final; inNxt += BlockSize) {
            uint32_t *out0 = out;
            out += HowManyMiniBlocks / 4U;      // save space for Bs[16] info
            uint32_t const* mbNxt = in;
            for (uint32_t i=0U; i < HowManyMiniBlocks;  in = mbNxt, ++i ) {
                mbNxt += MiniBlockSize;
                Bs[i] = maxbits(in, mbNxt);
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bs[i]);
                out += MiniBlockSize/32U * Bs[i];
            }
            assert( in = inNxt ); // after HowManyMiniBlocks, 'in' has advanced by exactly BlockSize
            static_assert( HowManyMiniBlocks == 16, "hard-wired for HowManyMiniBlocks == 16");
            *out0 = (Bs[0] << 24) | (Bs[1] << 16) | (Bs[2] << 8) | Bs[3];
            *++out0 = (Bs[4] << 24) | (Bs[5] << 16) | (Bs[6] << 8) | Bs[7];
            *++out0 = (Bs[8] << 24) | (Bs[9] << 16) | (Bs[10] << 8) | Bs[11];
            *++out0 = (Bs[12] << 24) | (Bs[13] << 16) | (Bs[14] << 8) | Bs[15];
        }
#endif
#if 0 // 1322 1330 1308 <-- loop unroll not good (ideal ~ 22-23 instructions in loop for Intel)
        uint32_t const* inNxt = in + BlockSize;
        for (const uint32_t * const final = in + length; inNxt <= final; inNxt += BlockSize) {
            uint32_t *out0 = out;
            out += HowManyMiniBlocks / 4U;
            uint32_t const* mbNxt;
            for (uint32_t i=0U; i < HowManyMiniBlocks;  ++i ) {
                mbNxt = in + MiniBlockSize;
                uint32_t Bsi = maxbits(in, mbNxt);
                uint32_t Bsi4 = Bsi<<24;
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bsi);
                out += MiniBlockSize/32 * Bsi;
                in = mbNxt;
                ++i;
                mbNxt = in + MiniBlockSize;
                Bsi = maxbits(in, mbNxt);
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bsi);
                Bsi4 |= Bsi << 16;
                out += MiniBlockSize/32 * Bsi;
                in = mbNxt;
                ++i;
                mbNxt = in + MiniBlockSize;
                Bsi = maxbits(in, mbNxt);
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bsi);
                Bsi4 |= Bsi << 8;
                out += MiniBlockSize/32 * Bsi;
                in = mbNxt;
                ++i;
                mbNxt = in + MiniBlockSize;
                Bsi = maxbits(in, mbNxt);
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bsi);
                *out0++ = Bsi4 | Bsi;
                out += MiniBlockSize/32 * Bsi;
                in = mbNxt;
                //*out0++ = (Bs[0] << 24) | (Bs[1] << 16) | (Bs[2] << 8) | Bs[3];
            }
        }
#endif
#if 0 // endian-safe? but logic error (original format relies on endianness of uint32_t)
        uint32_t const* inNxt = in + BlockSize;
        for (const uint32_t * const final = in + length; inNxt <= final; inNxt += BlockSize) {
            uint_least8_t *out0 = reinterpret_cast<uint_least8_t*>(out);
            out += HowManyMiniBlocks / 4U;      // save space for Bs[16] info
            uint32_t const* mbNxt = in;
            for (uint32_t i=0U; i < HowManyMiniBlocks;  in = mbNxt, ++i ) {
                mbNxt += MiniBlockSize;
                uint32_t Bsi = maxbits(in, mbNxt);
                SIMD_fastpackwithoutmask_32(in, reinterpret_cast<__m128i *>(out), Bsi);
                out += MiniBlockSize/32U * Bsi;
                *out0++ = static_cast<uint_least8_t>( Bsi ); // endian-safe, but original is endian-unsafe!
            }
            assert( in = inNxt ); // after HowManyMiniBlocks, 'in' has advanced by exactly BlockSize
            static_assert( HowManyMiniBlocks == 16, "hard-wired for HowManyMiniBlocks == 16");
            //*out0 = (Bs[0] << 24) | (Bs[1] << 16) | (Bs[2] << 8) | Bs[3];
            //*++out0 = (Bs[4] << 24) | (Bs[5] << 16) | (Bs[6] << 8) | Bs[7];
            //*++out0 = (Bs[8] << 24) | (Bs[9] << 16) | (Bs[10] << 8) | Bs[11];
            //*++out0 = (Bs[12] << 24) | (Bs[13] << 16) | (Bs[14] << 8) | Bs[15];
        }
#endif
        nvalue = out - initout;
    }
